{
  "version": 3,
  "sources": ["../../@strapi/blocks-react-renderer/src/Text.tsx", "../../@strapi/blocks-react-renderer/src/Block.tsx", "../../@strapi/blocks-react-renderer/src/BlocksRenderer.tsx"],
  "sourcesContent": ["import * as React from 'react';\n\nimport { useComponentsContext } from './BlocksRenderer';\n\ninterface TextInlineNode {\n  type: 'text';\n  text: string;\n  bold?: boolean;\n  italic?: boolean;\n  underline?: boolean;\n  strikethrough?: boolean;\n  code?: boolean;\n}\n\ntype Modifier = Exclude<keyof TextInlineNode, 'type' | 'text'>;\n\ntype TextInlineProps = Omit<TextInlineNode, 'type'>;\n\nconst replaceLineBreaks = (text: string) => {\n  const split = text.split(/\\r?\\n|\\r/g);\n  return (\n    <>\n      {split.map((part, idx) => (\n        <React.Fragment key={idx}>\n          {idx > 0 && <br />}\n          {part}\n        </React.Fragment>\n      ))}\n    </>\n  );\n};\n\nconst Text = ({ text, ...modifiers }: TextInlineProps) => {\n  // Get matching React component from the context\n  const { modifiers: modifierComponents, missingModifierTypes } = useComponentsContext();\n\n  const modifierNames = Object.keys(modifiers) as Modifier[];\n\n  // Loop on each active modifier to wrap the text in its component\n  return modifierNames.reduce(\n    (children, modifierName) => {\n      // Don't wrap the text if the modifier is disabled\n      if (!modifiers[modifierName]) {\n        return children;\n      }\n\n      const ModifierComponent = modifierComponents[modifierName];\n\n      if (!ModifierComponent) {\n        // Only warn once per missing modifier\n        if (!missingModifierTypes.includes(modifierName)) {\n          console.warn(\n            `[@strapi/block-react-renderer] No component found for modifier \"${modifierName}\"`\n          );\n          missingModifierTypes.push(modifierName);\n        }\n\n        // Don't throw an error, just ignore the modifier\n        return children;\n      }\n\n      return <ModifierComponent>{children}</ModifierComponent>;\n    },\n    // By default, return the text without any wrapper to avoid useless nesting\n    replaceLineBreaks(text)\n  );\n};\n\nexport type { TextInlineNode, Modifier };\nexport { Text };\n", "import * as React from 'react';\n\nimport { useComponentsContext, type Node, type GetPropsFromNode } from './BlocksRenderer';\nimport { Text } from './Text';\n\ntype BlockComponentProps = GetPropsFromNode<Node>;\n\ninterface BlockProps {\n  content: Node;\n}\n\nconst voidTypes = ['image'];\n\n/**\n * Add props that are specific to a block type, and not present in that node type\n */\nconst augmentProps = (content: Node) => {\n  const { children: childrenNodes, type, ...props } = content;\n\n  if (type === 'code') {\n    // Builds a plain text string from an array of nodes, regardless of links or modifiers\n    const getPlainText = (children: typeof childrenNodes): string => {\n      return children.reduce((currentPlainText, node) => {\n        if (node.type === 'text') {\n          return currentPlainText.concat(node.text);\n        }\n\n        if (node.type === 'link') {\n          return currentPlainText.concat(getPlainText(node.children));\n        }\n\n        return currentPlainText;\n      }, '');\n    };\n\n    return {\n      ...props,\n      plainText: getPlainText(content.children),\n    };\n  }\n\n  return props;\n};\n\nconst Block = ({ content }: BlockProps) => {\n  const { children: childrenNodes, type, ...props } = content;\n\n  // Get matching React component from the context\n  const { blocks, missingBlockTypes } = useComponentsContext();\n  const BlockComponent = blocks[type] as React.ComponentType<BlockComponentProps> | undefined;\n\n  if (!BlockComponent) {\n    // Only warn once per missing block\n    if (!missingBlockTypes.includes(type)) {\n      console.warn(`[@strapi/block-react-renderer] No component found for block type \"${type}\"`);\n      missingBlockTypes.push(type);\n    }\n\n    // Don't throw an error, just ignore the block\n    return null;\n  }\n\n  // Handle void types separately as they should not render children\n  if (voidTypes.includes(type)) {\n    return <BlockComponent {...props} />;\n  }\n\n  // Handle empty paragraphs separately as they should render a <br> tag\n  if (\n    type === 'paragraph' &&\n    childrenNodes.length === 1 &&\n    childrenNodes[0].type === 'text' &&\n    childrenNodes[0].text === ''\n  ) {\n    return <br />;\n  }\n\n  const augmentedProps = augmentProps(content);\n\n  return (\n    <BlockComponent {...augmentedProps}>\n      {childrenNodes.map((childNode, index) => {\n        if (childNode.type === 'text') {\n          const { type: _type, ...childNodeProps } = childNode;\n\n          // TODO use node as key with WeakMap\n          return <Text {...childNodeProps} key={index} />;\n        }\n\n        // TODO use node as key with WeakMap\n        return <Block content={childNode} key={index} />;\n      })}\n    </BlockComponent>\n  );\n};\n\nexport { Block };\n", "'use client';\n\nimport * as React from 'react';\n\nimport { Block } from './Block';\nimport { type Modifier, type TextInlineNode } from './Text';\n\n/* -------------------------------------------------------------------------------------------------\n * TypeScript types and utils\n * -----------------------------------------------------------------------------------------------*/\n\ninterface LinkInlineNode {\n  type: 'link';\n  url: string;\n  children: TextInlineNode[];\n}\n\ninterface ListItemInlineNode {\n  type: 'list-item';\n  children: DefaultInlineNode[];\n}\n\n// Inline node types\ntype DefaultInlineNode = TextInlineNode | LinkInlineNode;\ntype NonTextInlineNode = Exclude<DefaultInlineNode, TextInlineNode> | ListItemInlineNode;\n\ninterface ParagraphBlockNode {\n  type: 'paragraph';\n  children: DefaultInlineNode[];\n}\n\ninterface QuoteBlockNode {\n  type: 'quote';\n  children: DefaultInlineNode[];\n}\n\ninterface CodeBlockNode {\n  type: 'code';\n  children: DefaultInlineNode[];\n}\n\ninterface HeadingBlockNode {\n  type: 'heading';\n  level: 1 | 2 | 3 | 4 | 5 | 6;\n  children: DefaultInlineNode[];\n}\n\ninterface ListBlockNode {\n  type: 'list';\n  format: 'ordered' | 'unordered';\n  children: (ListItemInlineNode | ListBlockNode)[];\n}\n\ninterface ImageBlockNode {\n  type: 'image';\n  image: {\n    name: string;\n    alternativeText?: string | null;\n    url: string;\n    caption?: string | null;\n    width: number;\n    height: number;\n    formats?: Record<string, unknown>;\n    hash: string;\n    ext: string;\n    mime: string;\n    size: number;\n    previewUrl?: string | null;\n    provider: string;\n    provider_metadata?: unknown | null;\n    createdAt: string;\n    updatedAt: string;\n  };\n  children: [{ type: 'text'; text: '' }];\n}\n\n// Block node types\ntype RootNode =\n  | ParagraphBlockNode\n  | QuoteBlockNode\n  | CodeBlockNode\n  | HeadingBlockNode\n  | ListBlockNode\n  | ImageBlockNode;\ntype Node = RootNode | NonTextInlineNode;\n\n// Util to convert a node to the props of the corresponding React component\ntype GetPropsFromNode<T> = Omit<T, 'type' | 'children'> & {\n  children?: React.ReactNode;\n  // For code blocks, add a plainText property that is created by this renderer\n  plainText?: T extends { type: 'code' } ? string : never;\n};\n\n// Map of all block types to their matching React component\ntype BlocksComponents = {\n  [K in Node['type']]: React.ComponentType<\n    // Find the BlockProps in the union that match the type key of the current BlockNode\n    // and use it as the component props\n    GetPropsFromNode<Extract<Node, { type: K }>>\n  >;\n};\n\n// Map of all inline types to their matching React component\ntype ModifiersComponents = {\n  [K in Modifier]: React.ComponentType<{ children: React.ReactNode }>;\n};\n\n/* -------------------------------------------------------------------------------------------------\n * Default blocks and modifiers components\n * -----------------------------------------------------------------------------------------------*/\n\ninterface ComponentsContextValue {\n  blocks: BlocksComponents;\n  modifiers: ModifiersComponents;\n  missingBlockTypes: string[];\n  missingModifierTypes: string[];\n}\n\nconst defaultComponents: ComponentsContextValue = {\n  blocks: {\n    paragraph: (props) => <p>{props.children}</p>,\n    quote: (props) => <blockquote>{props.children}</blockquote>,\n    code: (props) => (\n      <pre>\n        <code>{props.plainText}</code>\n      </pre>\n    ),\n    heading: ({ level, children }) => {\n      switch (level) {\n        case 1:\n          return <h1>{children}</h1>;\n        case 2:\n          return <h2>{children}</h2>;\n        case 3:\n          return <h3>{children}</h3>;\n        case 4:\n          return <h4>{children}</h4>;\n        case 5:\n          return <h5>{children}</h5>;\n        case 6:\n          return <h6>{children}</h6>;\n      }\n    },\n    link: (props) => <a href={props.url}>{props.children}</a>,\n    list: (props) => {\n      if (props.format === 'ordered') {\n        return <ol>{props.children}</ol>;\n      }\n\n      return <ul>{props.children}</ul>;\n    },\n    'list-item': (props) => <li>{props.children}</li>,\n    image: (props) => <img src={props.image.url} alt={props.image.alternativeText || undefined} />,\n  },\n  modifiers: {\n    bold: (props) => <strong>{props.children}</strong>,\n    italic: (props) => <em>{props.children}</em>,\n    underline: (props) => <u>{props.children}</u>,\n    strikethrough: (props) => <del>{props.children}</del>,\n    code: (props) => <code>{props.children}</code>,\n  },\n  missingBlockTypes: [],\n  missingModifierTypes: [],\n};\n\n/* -------------------------------------------------------------------------------------------------\n * Context to pass blocks and inline components to the nested components\n * -----------------------------------------------------------------------------------------------*/\n\nconst ComponentsContext = React.createContext<ComponentsContextValue>(defaultComponents);\n\ninterface ComponentsProviderProps {\n  children: React.ReactNode;\n  value?: ComponentsContextValue;\n}\n\n// Provide default value so we don't need to import defaultComponents in all tests\nconst ComponentsProvider = ({ children, value = defaultComponents }: ComponentsProviderProps) => {\n  const memoizedValue = React.useMemo(() => value, [value]);\n\n  return <ComponentsContext.Provider value={memoizedValue}>{children}</ComponentsContext.Provider>;\n};\n\nfunction useComponentsContext() {\n  return React.useContext(ComponentsContext);\n}\n\n/* -------------------------------------------------------------------------------------------------\n * BlocksRenderer\n * -----------------------------------------------------------------------------------------------*/\n\ninterface BlocksRendererProps {\n  content: RootNode[];\n  blocks?: Partial<BlocksComponents>;\n  modifiers?: Partial<ModifiersComponents>;\n}\n\nconst BlocksRenderer = (props: BlocksRendererProps) => {\n  // Merge default blocks with the ones provided by the user\n  const blocks = {\n    ...defaultComponents.blocks,\n    ...props.blocks,\n  };\n\n  // Merge default modifiers with the ones provided by the user\n  const modifiers = {\n    ...defaultComponents.modifiers,\n    ...props.modifiers,\n  };\n\n  // Use refs because we can mutate them and avoid triggering re-renders\n  const missingBlockTypes = React.useRef<string[]>([]);\n  const missingModifierTypes = React.useRef<string[]>([]);\n\n  return (\n    <ComponentsProvider\n      value={{\n        blocks,\n        modifiers,\n        missingBlockTypes: missingBlockTypes.current,\n        missingModifierTypes: missingModifierTypes.current,\n      }}\n    >\n      {/* TODO use WeakMap instead of index as the key */}\n      {props.content.map((content, index) => (\n        <Block content={content} key={index} />\n      ))}\n    </ComponentsProvider>\n  );\n};\n\n/* -------------------------------------------------------------------------------------------------\n * Exports\n * -----------------------------------------------------------------------------------------------*/\n\nexport type { RootNode, Node, GetPropsFromNode };\nexport { ComponentsProvider, useComponentsContext, BlocksRenderer };\n"],
  "mappings": "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",
  "names": []
}
